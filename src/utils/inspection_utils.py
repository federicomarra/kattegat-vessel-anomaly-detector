import numpy as np
import pandas as pd
import config
import json
import random
from typing import Optional, List, Any, Union, Sequence
import folium
import pandas as pd

FEATURE_COLS = config.FEATURE_COLS
NUMERIC_COLS = config.NUMERIC_COLS

def denormalize_predictions(df: pd.DataFrame, metadata_path: str) -> pd.DataFrame:


    # Unpack
    def unpack_seq(seq):
        """
        seq: np.array of shape (T,) dtype=object, every element is an np.array of shape (12,)
        Returns a dict: {feature_name: list of length T}
        """
        arr = np.stack(seq)   
        
        if arr.shape[1] != len(FEATURE_COLS):
            raise ValueError(f"Expected {len(FEATURE_COLS)} features, but arr.shape={arr.shape}")
        
        out = {}
        for j, name in enumerate(FEATURE_COLS):
            out[name] = arr[:, j].tolist()
        return out


    unpacked_real = df['Sequence_real'].apply(unpack_seq)
    unpacked_pred = df['Sequence_pred'].apply(unpack_seq)

    real_cols = pd.DataFrame(unpacked_real.tolist()).add_prefix('real_')
    pred_cols = pd.DataFrame(unpacked_pred.tolist()).add_prefix('pred_')

    new_df = pd.concat(
        [
            df[['Segment_nr', 'MMSI', 'ShipTypeID', 'recon_error']],
            real_cols,
            pred_cols
        ],
        axis=1
    )

    # Denormalize
    with open(metadata_path, "r") as f:
        stats = json.load(f)

    mean = stats["mean"]
    std  = stats["std"]
    ship_type_to_id  = stats["ship_type_to_id"]


    # row0 = new_df.iloc[0]
    # print(">>> raw normalized real_lon (before denorm)")
    # print(row0["real_Longitude"])               
    # print("unique (norm):", sorted(set(row0["real_Longitude"]))[:10])

    # i = NUMERIC_COLS.index("Longitude")  
    # m = mean[i]
    # s = std[i]

    # print("mean_lon:", m, "std_lon:", s)

    # denorm_example = [x * s + m for x in row0["real_Longitude"]]
    # print("denorm_example:", denorm_example[:10])
    # print("unique (denorm):", sorted(set(denorm_example))[:10])


    for i, feat in enumerate(NUMERIC_COLS):
        m = mean[i]
        s = std[i]
        
        new_df[f"real_{feat}"] = new_df[f"real_{feat}"].apply(
            lambda lst: [x * s + m for x in lst]
        )
        new_df[f"pred_{feat}"] = new_df[f"pred_{feat}"].apply(
            lambda lst: [x * s + m for x in lst]
    )
        
    # reconstruct COG (degrees) from sin/cos components for real and pred
    def _reconstruct_angle_deg(sin_seq, cos_seq):
        if sin_seq is None or cos_seq is None:
            return []
        out = []
        for s, c in zip(sin_seq, cos_seq):
            try:
                if s is None or c is None or (isinstance(s, float) and np.isnan(s)) or (isinstance(c, float) and np.isnan(c)):
                    out.append(None)
                else:
                    out.append(float((np.degrees(np.arctan2(s, c)) + 360.0) % 360.0))
            except Exception:
                out.append(None)
        return out

    if "real_COG_sin" in new_df.columns and "real_COG_cos" in new_df.columns:
        new_df["real_COG"] = [
            _reconstruct_angle_deg(sin_seq, cos_seq)
            for sin_seq, cos_seq in zip(new_df["real_COG_sin"], new_df["real_COG_cos"])
        ]

    if "pred_COG_sin" in new_df.columns and "pred_COG_cos" in new_df.columns:
        new_df["pred_COG"] = [
            _reconstruct_angle_deg(sin_seq, cos_seq)
            for sin_seq, cos_seq in zip(new_df["pred_COG_sin"], new_df["pred_COG_cos"])
        ]

    # drop the sin/cos columns to avoid confusion (if present)
    for col in ("real_COG_sin", "real_COG_cos", "pred_COG_sin", "pred_COG_cos"):
        if col in new_df.columns:
            new_df.drop(columns=col, inplace=True)
    

    # Map ShipTypeID to ShipType
    new_df["ShipType"] = new_df["ShipTypeID"].astype(str).map(ship_type_to_id)


    return new_df



def save_interactive_html(
    df: pd.DataFrame,
    out_html: str = "ais_maps.html",
    mmsi: Optional[Union[int, Sequence[int]]] = None,
    segment: Optional[Union[int, Sequence[int]]] = None,
    n_random: int = 8,
    tiles: str = "OpenStreetMap",
    zoom_start: int = 20,
    real_color: str = "blue",
    pred_color: str = "red",
    circle_radius: float = 4,
    head_n: Optional[int] = None,
):
    """
    Creates an interactive HTML file that incorporates the map generated by
    plot_real_pred_on_map and a sidebar with the list of displayed rows.
    Clicking an entry in the sidebar centers the map on the first valid point
    (real) of that row.

    Added parameter:
    - head_n: if provided (>0) takes the first head_n rows (on the entire df if there are no filters,
      or on the filtered rows if mmsi/segment are specified). head_n has priority over n_random.
    """


    # generates the map
    m = plot_real_pred_on_map(
        df,
        mmsi=mmsi,
        segment=segment,
        n_random=n_random,
        tiles=tiles,
        zoom_start=zoom_start,
        real_color=real_color,
        pred_color=pred_color,
        circle_radius=circle_radius,
        head_n=head_n,
    )

    # determines the displayed rows (same logic used in the function above)
    rows = _select_rows_by_mmsi_or_random(df, mmsi=mmsi, segment=segment, n_random=n_random, head_n=head_n)

    # collects the first valid position for each row (to be used as target)
    entries = []
    for _, row in rows.iterrows():
        mmsi_val = row.get("MMSI", "")
        seg = row.get("Segment_nr", "")
        lat_found = None
        lon_found = None
        for la, lo in zip(_ensure_seq(row.get("real_Latitude")),
                          _ensure_seq(row.get("real_Longitude"))):
            la_f = _to_float_safe(la)
            lo_f = _to_float_safe(lo)
            if la_f is not None and lo_f is not None:
                lat_found, lon_found = la_f, lo_f
                break
        entries.append({"mmsi": mmsi_val, "seg": seg, "lat": lat_found, "lon": lon_found})

    # render the complete map (HTML)
    full_map_html = m.get_root().render()

    # locate the <div ... id="map_..."> block to insert the sidebar before the map
    id_marker = f'id="map_{m._id}"'
    idx = full_map_html.find(id_marker)
    if idx == -1:
        # fallback: write simple map file as saved by folium
        m.save(out_html)
        return out_html

    # find the start of the div containing the found id
    start_div = full_map_html.rfind("<div", 0, idx)
    if start_div == -1:
        m.save(out_html)
        return out_html

    # generate HTML for the sidebar and script to center the map
    map_var = f"map_{m._id}"
    # build list of items
    list_items = []
    for i, e in enumerate(entries):
        label = f"MMSI: {e['mmsi']} â€” Seg: {e['seg']}"
        lat = "null" if e["lat"] is None else f"{e['lat']:.8f}"
        lon = "null" if e["lon"] is None else f"{e['lon']:.8f}"
        list_items.append(f'<li><a href="#" onclick="focusOn({i});return false;">{label}</a></li>')

    sidebar_html = f"""
    <div class="ais-sidebar" style="position:fixed;left:0;top:0;bottom:0;width:300px;overflow:auto;background:#f7f7f8;border-right:1px solid #ddd;padding:10px;z-index:1000;">
        <h3 style="margin-top:0;">AIS tracks</h3>
        <p style="font-size:90%;margin:0 0 8px 0;">Shown rows: {len(entries)}</p>
        <ul style="padding-left:16px;margin:0;">{''.join(list_items)}</ul>
        <hr/>
        <p style="font-size:85%;">Click an entry to center the map on its first valid point.</p>
    </div>
    <div style="margin-left:300px;"></div>
    <script>
        const ais_points = [{','.join(
            'null' if e['lat'] is None else f'[{e["lat"]:.8f},{e["lon"]:.8f}]' for e in entries
        )}];

        function focusOn(i) {{
            const pt = ais_points[i];
            if (!pt || pt[0] === null) return;
            const mz = {zoom_start};
            const mapobj = window["{map_var}"];
            if (mapobj && mapobj.setView) {{
                mapobj.setView(pt, mz);
            }}
        }}
    </script>
    """

    # inserisci sidebar_html prima del div della mappa
    new_html = full_map_html[:start_div] + sidebar_html + full_map_html[start_div:]

    # salva il file finale
    with open(out_html, "w", encoding="utf-8") as f:
        f.write(new_html)

    return out_html






























#### HELPER FUNCTIONS ####

def _ensure_seq(x: Any) -> List:
    """
    Returns a list from x.
    Handles None, scalar values, and strings (returns an empty list in those cases).
    Does not truncate or pad: returns all elements of the sequence.
    """
    if x is None:
        return []
    # strings are not considered sequences of coordinates
    if isinstance(x, str):
        return []
    try:
        if len(x) == 0:
            return []
    except TypeError:
        # scalar not iterable
        return []

    # in new_df x is already a list of floats
    return list(x)


def _to_float_safe(v):
    try:
        return float(v)
    except Exception:
        return None


def _select_rows_by_mmsi_or_random(
    df: pd.DataFrame,
    mmsi: Optional[Union[int, Sequence[int]]] = None,
    segment: Optional[Union[int, Sequence[int]]] = None,
    n_random: int = 10,
    head_n: Optional[int] = None,
) -> pd.DataFrame:
    """
    If filters are passed, returns the corresponding rows:
      - mmsi can be int or sequence (list/tuple/series/ndarray)
      - segment can be int or sequence (list/tuple/series/ndarray) and filters the 'Segment_nr' column

    Behavior:
      - if head_n is provided (>0):
          * if filters are specified (mmsi or segment): filters the dataframe and returns the first head_n rows of the result
          * if no filters are specified: returns df.head(head_n)
      - otherwise:
          - if both mmsi and segment are None: random sample of n_random rows
          - if one or both are specified: filters the dataframe by the criteria (intersection)
    """
    if head_n is not None:
        if head_n <= 0:
            raise ValueError("head_n must be > 0 if specified.")
        # if no filters, take the first head_n rows of the entire df
        if mmsi is None and segment is None:
            return df.head(min(head_n, len(df)))

    # build filter mask (default True)
    mask = pd.Series(True, index=df.index)

    if mmsi is not None:
        if isinstance(mmsi, (list, tuple, set, pd.Series)):
            mask &= df["MMSI"].isin(list(mmsi))
        else:
            mask &= df["MMSI"] == mmsi

    if segment is not None:
        if isinstance(segment, (list, tuple, set, pd.Series)):
            mask &= df["Segment_nr"].isin(list(segment))
        else:
            mask &= df["Segment_nr"] == segment

    rows = df[mask]

    if rows.empty:
        raise ValueError(f"No rows found for filters: mmsi={mmsi}, segment={segment}.")

    # if head_n is specified and there are filters, take the first head_n rows of the filtered result
    if head_n is not None:
        return rows.head(min(head_n, len(rows)))

    # no filters and no head_n: random sample
    if mmsi is None and segment is None:
        if n_random <= 0:
            raise ValueError("n_random must be > 0 if no filters are specified.")
        return df.sample(n=min(n_random, len(df)), random_state=42)

    return rows


def plot_real_pred_on_map(
    df: pd.DataFrame,
    mmsi: Optional[Union[int, Sequence[int]]] = None,
    segment: Optional[Union[int, Sequence[int]]] = None,
    n_random: int = 10,
    tiles: str = "OpenStreetMap",
    zoom_start: int = 6,
    real_color: str = "blue",
    pred_color: str = "red",
    circle_radius: float = 4,
    save_html: Optional[str] = None,
    head_n: Optional[int] = None,
) -> folium.Map:
    """
    Creates a folium map where the 'real' and 'pred' points/paths
    present in the dataframe are projected.

    Added parameter:
    - head_n: if provided (>0) takes the first head_n rows (on the entire df if no filters,
      or on the filtered rows if mmsi/segment are specified). head_n has priority over n_random.
    """
    # select rows
    rows = _select_rows_by_mmsi_or_random(df, mmsi=mmsi, segment=segment, n_random=n_random, head_n=head_n)

    # calculate map center using the first valid point (real)
    center_lat = None
    center_lon = None
    for _, row in rows.iterrows():
        lats = _ensure_seq(row.get("real_Latitude"))
        lons = _ensure_seq(row.get("real_Longitude"))
        for la, lo in zip(lats, lons):
            la_f = _to_float_safe(la)
            lo_f = _to_float_safe(lo)
            if la_f is not None and lo_f is not None:
                center_lat, center_lon = la_f, lo_f
                break
        if center_lat is not None:
            break
    if center_lat is None:
        # fallback: 0,0
        center_lat, center_lon = 0.0, 0.0

    m = folium.Map(location=[center_lat, center_lon], tiles=tiles, zoom_start=zoom_start)

    # for each row draw polylines and markers
    for idx, row in rows.iterrows():
        seg = row.get("Segment_nr", "")
        mmsi_val = row.get("MMSI", "")

        # extract REAL sequences from new_df
        lat_real = _ensure_seq(row.get("real_Latitude"))
        lon_real = _ensure_seq(row.get("real_Longitude"))
        sog_real = _ensure_seq(row.get("real_SOG"))
        cog_real = _ensure_seq(row.get("real_COG"))

        # extract PRED sequences from new_df
        lat_pred = _ensure_seq(row.get("pred_Latitude"))
        lon_pred = _ensure_seq(row.get("pred_Longitude"))
        sog_pred = _ensure_seq(row.get("pred_SOG"))
        cog_pred = _ensure_seq(row.get("pred_COG"))

        # build list of valid coordinates for real and pred
        coords_real = []
        popups_real = []
        for la, lo, sog, cog in zip(lat_real, lon_real, sog_real, cog_real):
            la_f = _to_float_safe(la)
            lo_f = _to_float_safe(lo)
            if la_f is not None and lo_f is not None:
                coords_real.append((la_f, lo_f))
                popups_real.append(
                    f"MMSI: {mmsi_val}<br>Seg: {seg}<br>SOG: {sog}<br>COG: {cog}"
                )

        coords_pred = []
        popups_pred = []
        for la, lo, sog, cog in zip(lat_pred, lon_pred, sog_pred, cog_pred):
            la_f = _to_float_safe(la)
            lo_f = _to_float_safe(lo)
            if la_f is not None and lo_f is not None:
                coords_pred.append((la_f, lo_f))
                popups_pred.append(
                    f"MMSI: {mmsi_val}<br>Seg: {seg} (pred)<br>SOG: {sog}<br>COG: {cog}"
                )

        # add polyline and markers for real
        if coords_real:
            folium.PolyLine(locations=coords_real, color=real_color, weight=3, opacity=0.8).add_to(m)
            for (lat_pt, lon_pt), popup in zip(coords_real, popups_real):
                folium.CircleMarker(
                    location=(lat_pt, lon_pt),
                    radius=circle_radius,
                    color=real_color,
                    fill=True,
                    fill_color=real_color,
                    fill_opacity=0.9,
                    popup=folium.Popup(popup, max_width=300),   
                ).add_to(m)

        # add polyline and markers for pred
        if coords_pred:
            folium.PolyLine(locations=coords_pred, color=pred_color, weight=3, opacity=0.8).add_to(m)
            for (lat_pt, lon_pt), popup in zip(coords_pred, popups_pred):
                folium.CircleMarker(
                    location=(lat_pt, lon_pt),
                    radius=circle_radius,
                    color=pred_color,
                    fill=True,
                    fill_color=pred_color,
                    fill_opacity=0.7,
                    popup=folium.Popup(popup, max_width=300),
                ).add_to(m)

    if save_html:
        m.save(save_html)

    return m
